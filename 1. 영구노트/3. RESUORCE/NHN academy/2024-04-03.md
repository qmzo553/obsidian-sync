### 주제 : 파일 조직과 인덱스

### 날짜 : 2024-04-03 08:42
----
### 메모
> log는 정보일까? log는 의사결정을 하는데 도움을 주진 않는다. 하지만 어떤 측면에서는 정보라고 볼 수 있을 듯 하다.
> 개체 무결성을 지키기 위한 것 : 키, 참조 무결성을 지키기 위한 것 : 외래 키
> 데이터 베이스 설계를 할 때, 어떻게 옵션을 주는가에 따라 다르다.

> 비용 모델 개요
> 데이터베이스에서는 질의가 요청 될 때 여러 실행 계획을 세우고 최적화된 방법을 찾아 실행한다.
> 쿼리 최적화(Query Optimizer)는 쿼리 기반, 비용 기반 등의 모델로 실행 계획을 비교한다.
> 비용 측정
> 	- 데이터 페이지의 개수 B
> 	- 페이지에 속한 레코드의 개수 R
> 	- 디스크 페이지를 하나 읽는 시간을 D
> 	- 한 레코드를 처리하는데 걸리는 시간 C
> 	- 한 레코드에 해시 함수를 적용하는데 걸리는 시간 H

> 파일 조직법과 비교 기준 연산
> 스캔(Scan) : 파일에 있는 모든 레코드를 가져옴. 파일에 있는 페이지들은 디스크로 부터 버퍼 풀로 반입 되어야 한다.
> 동등 셀렉션(Equality Selection) : 질의에서 요구하는 검색어와 같은 문자열임을 만족하는 모든 레코드를 가져옴
> 범위 셀렉션(Range Selection) : 특정 범위에 해당하는 모든 레코드를 가져옴
> 삽입(Insertion) : 주어진 레코드를 파일에 삽입
> 삭제(Deletion) : RID로 명세된 레코드를 삭제

> Heap 파일
> 	- 정렬되지 않은 단순한 형태의 파일
> 	- scan :  B(D + RC)
> 	- equality selection :  후보 키에 대한 연산일 경우 0.5B(D + RC). 후보 키가 아닌 경우 스캔과 동일
> 	- range selection : scan 과 동일
> 	- 삽입 레코드가 항상 파일의 끝에 삽입 된다고 가정할 경우 2D + C
> 	- 삭제 탐색 비용 + C + D

> 정렬 파일
> 	- 특정 필드를 기준으로 정렬된 파일
> 	- scan : heap file 과 다르지 않음 B(D + RC)
> 	- equality selection : 정렬 기준으로 검색할 경우 이진 탑색으로 DlogB + ClogR. 정렬 필드가 아닌 경우 scan과 동일
> 	- range selection : 정렬 기준으로 검색할 경우 첫 레코드를 찾는데 equality selection과 동일. 이후 범위 내 scan
> 	- insertion, delete : 정렬 순서를 유지하기 위해 레코드가 삽입 될 위치를 검색 후 레코드 추가. 후속 페이지를 모두 로드 하여 다시 저장. 탐색 비용 + B(D + RC)

> 해시 파일
> 	- 특정 필드를 기준으로 정렬된 파일
> 	- scan : heap file 과 다르지 않음. B(D + RC)
> 	- equality selection : 정렬 기준 필드로 검색할 경우 이진 탐색으로 DlogB + ClogR. 정렬 필드가 아닌 경우 scan 과 동일
> 	- range selection : 정렬 기준 필드로 검색할 경우 첫 레코드를 찾는데 equality selection과 동일. 이후 범위 내 scan 
> 	- insertion, delete : 정렬 순서를 유지하기 위해 레코드가 삽입될 위치를 검색 후 레코드 추가. 후속 페이지를 모두 로드하여 다시 저장. 탐색 비용 + B(D + RC)

> 파일 조직 선택
> ![[Pasted image 20240403100155.png]]
> 일반적으로 equality selection과 range selection을 많이 사용한다.

> 인덱스 개요
> 해당 파일의 기본적인 레코드 조작법으로는 효율적으로 지원되지 않는 연산의 속도를 높이기 위해 만드는 보조적인 자료구조
> 데이터 엔드리(Data Entry)들의 모임

> clustered index
> 	- 파일을 조직할 때 레코드의 순서를 파일에 대한 인덱스의 순서와 동일한 순서로 유지
> 	- 파일의 재조직이 필요한 구조
> 	- 데이터가 삽입/삭제 될 때 마다 정렬 순서를 유지하기 위해서 그 주변의 데이터를 이동해야 한다.
> 	- 파일이 동적으로 변하는 경우 유지 관리 오버헤드가 높음

> non-clustered index
> 	- 하나의 데이터 파일은 하나의 탐색 키에 대해서만 clustering 될 수 있다.
> 	- 하나의 데이터 파일에 대해 하나의 clustered index만 만들 수 있다.
> 	- clustered index 구조 파일의 키가 아닌 필드의 빠른 검색을 위한 보조 자료구조

 > 밀집 인덱스와 희소 인덱스
> 밀집 인덱스(Dense Index) : 파일에 있는 모든 탐색 키 값에 대해 데이터 엔트리를 구성
> 희소 인덱스(Sparse Index) : 데이터 파일의 페이지 별로 하나의 데이터 엔트리를 구성

> 기본 인덱스와 보조 인덱스
> 기본 인덱스(Primary Index) : 기본 키를 포함한 필드들에 대한 보조 인덱스
> 보조 인덱스(Secondary Index) : 기본 인덱스 이외의 인덱스들
> 유일 인덱스(Unique Index) : 해당 탐색 키에 후보 키가 포함되면, 해당 탐색 키에 대해 만들어진 인덱스

### 출처(참고 문헌)
-

### 연결 문서
-
