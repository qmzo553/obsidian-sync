### 주제 : 파일 조직과 인덱스

### 날짜 : 2024-04-03 08:42
----
### 메모
> log는 정보일까? log는 의사결정을 하는데 도움을 주진 않는다. 하지만 어떤 측면에서는 정보라고 볼 수 있을 듯 하다.
> 개체 무결성을 지키기 위한 것 : 키, 참조 무결성을 지키기 위한 것 : 외래 키
> 데이터 베이스 설계를 할 때, 어떻게 옵션을 주는가에 따라 다르다.

> 비용 모델 개요
> 데이터베이스에서는 질의가 요청 될 때 여러 실행 계획을 세우고 최적화된 방법을 찾아 실행한다.
> 쿼리 최적화(Query Optimizer)는 쿼리 기반, 비용 기반 등의 모델로 실행 계획을 비교한다.
> 비용 측정
> 	- 데이터 페이지의 개수 B
> 	- 페이지에 속한 레코드의 개수 R
> 	- 디스크 페이지를 하나 읽는 시간을 D
> 	- 한 레코드를 처리하는데 걸리는 시간 C
> 	- 한 레코드에 해시 함수를 적용하는데 걸리는 시간 H

> 파일 조직법과 비교 기준 연산
> 스캔(Scan) : 파일에 있는 모든 레코드를 가져옴. 파일에 있는 페이지들은 디스크로 부터 버퍼 풀로 반입 되어야 한다.
> 동등 셀렉션(Equality Selection) : 질의에서 요구하는 검색어와 같은 문자열임을 만족하는 모든 레코드를 가져옴
> 범위 셀렉션(Range Selection) : 특정 범위에 해당하는 모든 레코드를 가져옴
> 삽입(Insertion) : 주어진 레코드를 파일에 삽입
> 삭제(Deletion) : RID로 명세된 레코드를 삭제

> Heap 파일
> 	- 정렬되지 않은 단순한 형태의 파일
> 	- scan :  B(D + RC)
> 	- equality selection :  후보 키에 대한 연산일 경우 0.5B(D + RC). 후보 키가 아닌 경우 스캔과 동일
> 	- range selection : scan 과 동일
> 	- 삽입 레코드가 항상 파일의 끝에 삽입 된다고 가정할 경우 2D + C
> 	- 삭제 탐색 비용 + C + D

> 정렬 파일
> 	- 특정 필드를 기준으로 정렬된 파일
> 	- scan : heap file 과 다르지 않음 B(D + RC)
> 	- equality selection : 정렬 기준으로 검색할 경우 이진 탑색으로 DlogB + ClogR. 정렬 필드가 아닌 경우 scan과 동일
> 	- range selection : 정렬 기준으로 검색할 경우 첫 레코드를 찾는데 equality selection과 동일. 이후 범위 내 scan
> 	- insertion, delete : 정렬 순서를 유지하기 위해 레코드가 삽입 될 위치를 검색 후 레코드 추가. 후속 페이지를 모두 로드 하여 다시 저장. 탐색 비용 + B(D + RC)

> 해시 파일
> 	- 특정 필드를 기준으로 정렬된 파일
> 	- scan : heap file 과 다르지 않음. B(D + RC)
> 	- equality selection : 정렬 기준 필드로 검색할 경우 이진 탐색으로 DlogB + ClogR. 정렬 필드가 아닌 경우 scan 과 동일
> 	- range selection : 정렬 기준 필드로 검색할 경우 첫 레코드를 찾는데 equality selection과 동일. 이후 범위 내 scan 
> 	- insertion, delete : 정렬 순서를 유지하기 위해 레코드가 삽입될 위치를 검색 후 레코드 추가. 후속 페이지를 모두 로드하여 다시 저장. 탐색 비용 + B(D + RC)

> 파일 조직 선택
> ![[Pasted image 20240403100155.png]]
> 일반적으로 equality selection과 range selection을 많이 사용한다.

> 인덱스 개요
> 해당 파일의 기본적인 레코드 조작법으로는 효율적으로 지원되지 않는 연산의 속도를 높이기 위해 만드는 보조적인 자료구조
> 데이터 엔드리(Data Entry)들의 모임

> clustered index
> 	- 파일을 조직할 때 레코드의 순서를 파일에 대한 인덱스의 순서와 동일한 순서로 유지
> 	- 파일의 재조직이 필요한 구조
> 	- 데이터가 삽입/삭제 될 때 마다 정렬 순서를 유지하기 위해서 그 주변의 데이터를 이동해야 한다.
> 	- 파일이 동적으로 변하는 경우 유지 관리 오버헤드가 높음

> non-clustered index
> 	- 하나의 데이터 파일은 하나의 탐색 키에 대해서만 clustering 될 수 있다.
> 	- 하나의 데이터 파일에 대해 하나의 clustered index만 만들 수 있다.
> 	- clustered index 구조 파일의 키가 아닌 필드의 빠른 검색을 위한 보조 자료구조

 > 밀집 인덱스와 희소 인덱스
> 밀집 인덱스(Dense Index) : 파일에 있는 모든 탐색 키 값에 대해 데이터 엔트리를 구성
> 희소 인덱스(Sparse Index) : 데이터 파일의 페이지 별로 하나의 데이터 엔트리를 구성

> 기본 인덱스와 보조 인덱스
> 기본 인덱스(Primary Index) : 기본 키를 포함한 필드들에 대한 보조 인덱스
> 보조 인덱스(Secondary Index) : 기본 인덱스 이외의 인덱스들
> 유일 인덱스(Unique Index) : 해당 탐색 키에 후보 키가 포함되면, 해당 탐색 키에 대해 만들어진 인덱스

> 복합 키 인덱스
> 인덱스가 여러 개의 필드를 포함하는 경우 복합 키(Composeite Key) 또는 접합 키(Concatenated Key)라 한다.
> 데이터 조직과 쿼리 형태에 따라 높은 성능을 보인다.

> index 와 order by 중 무엇이 더 빠를까? -> 데이터 양이 많을수록 order by가 느리고, 데이터가 엄청 많을시 임시 index를 만든다.

> 관계 대수 개요
> 	- 관계 대수식(Relational Algebra Expression)은 연산자들의 모임을 사용해서 구성된 대수식
> 	- 기존의 릴레이션들로 부터 새로운 릴레이션을 생성
> 	- 하나 또는 두 개의 릴레이션을 파라미터로 하나의 릴레이션 인스턴스를 반환
> 데이터베이스는 릴레이션의 집합이다.

> 셀렉션과 프로젝션
> 	- 릴레이션에서 투플들을 선택(Selection) 할 수 있는 연산자 시그마( δ ) -> sql query 의 where
> 	- 필드들을 추출(Projection) 할 수 있는 연산자 파이( π ) -> sql query 의 select
> 	- 단일 릴레이션에 있는 데이터를 조작하는데 사용

> 집합 연산
> 	- 합집합, 교집합, 차지합, 카티션 프로덕트와 같은 표준 집합 연산
> 	- 합집합(Union) : 필드의 수가 같고, 왼쪽부터 오른쪽으로 가면서 순서대로 대응되는 필드들의 도메인이 같을때 가능하다.
> 	- 교집합(Intersection) : 양쪽에 속하는 모든 투플로 구성된 릴레이션 인스턴스를 만든다. 이때, 두 릴레이션은 합병 가능해야 함
> 	- 차집합(Set-different) : R에는 속하고 S에는 속하지 않는 모든 투플로 구성된 릴레이션 인스턴스를 만든다. 두 릴레이션은 합병 가능해야 함
> 	- 카디션 프로덕트(Cartisian Product) : R의 모든 필드와 S의 모든 필드를 순서대로 가지는 릴레이션 인스턴트를 만든다.

> 이름 바꾸기
> 	- 릴레이션에서 필드의 이름을 변경(Renaming)할 수 있는 연산자 로우( ρ )
> 	- 긴 대수식을 작은 부분으로 나누어 결과 인스턴스에 이름을 줄 수 있도록 하는 것이 편리함

> 조인(join)
> 	- 둘 이상의 릴레이션으로 부터 정보를 조합하는 연산(⋈)
> 	- 유도된 연산으로, 카티션 프로덕트와 프로젝션 연산을 함께 실행하여 얻은 결과와 동일

> 

|      |      |          |
| ---- | ---- | -------- |


### 출처(참고 문헌)
-

### 연결 문서
-
